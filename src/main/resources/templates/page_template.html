<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Notion-like Editor</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
  <link rel="stylesheet" href="/static/styles.css">
</head>

<body>
  <div id="editor-container">
    <div id="editor">
      <!-- Blocks will be dynamically added here -->
    </div>
  </div>

  <button id="save-button">Save Document</button>

  <div id="command-menu" class="command-menu">
    <div class="command-item" data-type="h1">
      <div class="command-item-icon">H1</div>
      <div class="command-item-text">
        <div class="command-item-title">Heading 1</div>
        <div class="command-item-description">Big section heading</div>
      </div>
    </div>
    <div class="command-item" data-type="h2">
      <div class="command-item-icon">H2</div>
      <div class="command-item-text">
        <div class="command-item-title">Heading 2</div>
        <div class="command-item-description">Medium section heading</div>
      </div>
    </div>
    <div class="command-item" data-type="todo">
      <div class="command-item-icon">‚òê</div>
      <div class="command-item-text">
        <div class="command-item-title">To-do list</div>
        <div class="command-item-description">Track tasks with a to-do list</div>
      </div>
    </div>
    <div class="command-item" data-type="code">
      <div class="command-item-icon">‚å®Ô∏è</div>
      <div class="command-item-text">
        <div class="command-item-title">Code</div>
        <div class="command-item-description">Add code with syntax highlighting</div>
      </div>
    </div>
    <div class="command-item" data-type="quote">
      <div class="command-item-icon">‚ùù</div>
      <div class="command-item-text">
        <div class="command-item-title">Quote</div>
        <div class="command-item-description">Capture a quote</div>
      </div>
    </div>
    <div class="command-item" data-type="bullet">
      <div class="command-item-icon">‚Ä¢</div>
      <div class="command-item-text">
        <div class="command-item-title">Bullet List</div>
        <div class="command-item-description">Create a simple bullet list</div>
      </div>
    </div>
    <div class="command-item" data-type="page">
      <div class="command-item-icon">üìÑ</div>
      <div class="command-item-text">
        <div class="command-item-title">New Page</div>
        <div class="command-item-description">Create a new linked page</div>
      </div>
    </div>
  </div>

  <!-- Store the title and content as global variables -->
  <script>
    // These values will be populated by the server
    window.PAGE_TITLE = "{{title}}";
    window.PAGE_CONTENT = "{{content}}";
  </script>

  <!-- Include the NotionLikeEditor class -->
  <script>
    class Slipstream {
      constructor(container) {
        this.container = container;
        this.converter = new showdown.Converter({
          tables: true,
          tasklists: true,
          strikethrough: true,
          literalMidWordUnderscores: true,
          simpleLineBreaks: true
        });
        this.commandMenu = document.getElementById('command-menu');
        this.activeBlock = null;
        this.isInEditMode = true;
        this.blockTypes = new Map(); // Store block types for persistence

        this.initializeEditor();
        this.setupEventListeners();
      }

      initializeEditor() {
        // Check if we have pre-loaded title and content
        const pageTitle = window.PAGE_TITLE || '';
        const pageContent = window.PAGE_CONTENT || '';

        // Clear the container first
        this.container.innerHTML = '';

        // Add title block if we have a title
        if (pageTitle) {
          this.addTitleBlock(pageTitle);
        }

        // Add content blocks if we have content
        if (pageContent) {
          this.loadContentFromMarkdown(pageContent);
        } else {
          // Create initial empty block if there's no content
          this.addBlock();
        }

        // Setup save button
        document.getElementById('save-button').addEventListener('click', () => this.saveDocument());
      }

      addTitleBlock(title) {
        const titleBlock = document.createElement('div');
        titleBlock.className = 'block relative mb-6';
        titleBlock.innerHTML = `
          <div class="block-placeholder">üìÑ</div>
          <div class="block-content text-3xl font-bold" contenteditable="true">${title}</div>
          <div class="markdown-rendered prose text-3xl font-bold hidden"></div>
        `;

        this.container.appendChild(titleBlock);

        // Set up event listeners for this block
        this.setupBlockEventListeners(titleBlock);
      }

      loadContentFromMarkdown(markdown) {
        // Split content by double newlines to create blocks
        const blocks = markdown.split(/\n\n+/);
        blocks.forEach(blockContent => {
          if (blockContent.trim()) {
            const block = this.addBlock(null, false);
            const content = block.querySelector('.block-content');
            // Set the content
            content.textContent = blockContent;
            // Update block type based on content
            this.updateBlockType(block);
            // Switch to render mode for the block
            this.switchToRenderMode(block);
          }
        });
      }

      setupEventListeners() {
        // Global keydown event
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            this.hideCommandMenu();
          }
        });

        // Command menu listeners
        this.commandMenu.addEventListener('click', (e) => {
          const item = e.target.closest('.command-item');
          if (item) {
            this.applyCommand(item.dataset.type);
          }
        });

        // Click outside to hide command menu
        document.addEventListener('click', (e) => {
          if (!this.commandMenu.contains(e.target) && !e.target.closest('.block-content')) {
            this.hideCommandMenu();
          }
        });
      }

      setupBlockEventListeners(block) {
        const content = block.querySelector('.block-content');
        const renderedContent = block.querySelector('.markdown-rendered');

        // Input event for content changes
        content.addEventListener('input', () => {
          this.handleContentChange(block);
        });

        // Keydown events for special handling
        content.addEventListener('keydown', (e) => {
          this.handleKeyDown(e, block);
        });

        // Focus handling
        content.addEventListener('focus', () => {
          this.setActiveBlock(block);
        });

        // Handle clicks on rendered content to switch to edit mode
        if (renderedContent) {
          renderedContent.addEventListener('click', () => {
            this.switchToEditMode(block);
          });
        }

        // Handle paste events
        content.addEventListener('paste', (e) => {
          this.handlePaste(e, block);
        });

        // Handle blur to switch to render mode
        content.addEventListener('blur', () => {
          // Only switch if not focused on command menu
          if (!this.commandMenu.contains(document.activeElement)) {
            this.switchToRenderMode(block);
          }
        });
      }

      setActiveBlock(block) {
        // Remove active class from all blocks
        const allBlocks = this.container.querySelectorAll('.block');
        allBlocks.forEach(b => b.classList.remove('active'));
        // Add active class to current block
        block.classList.add('active');
        this.activeBlock = block;
      }

      handlePaste(e, block) {
        const target = e.target;
        if (!target.classList.contains('block-content')) return;
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf("image") !== -1) {
            const blob = items[i].getAsFile();
            const reader = new FileReader();
            reader.onload = (event) => {
              const content = block.querySelector('.block-content');
              // Insert markdown image syntax
              const imageMarkdown = `![Pasted Image](${event.target.result})`;
              content.textContent += imageMarkdown;
              // Update the block
              this.handleContentChange(block);
            };
            reader.readAsDataURL(blob);
            // Prevent default paste
            e.preventDefault();
            break;
          }
        }
      }

      saveDocument() {
        // Extract page ID from the current URL
        const pageIdMatch = window.location.pathname.match(/\/pages\/(\d+)/);
        const pageId = pageIdMatch ? pageIdMatch[1] : null;
        // Get title from the first block if it exists
        const firstBlock = this.container.querySelector('.block');
        let title = '';
        if (firstBlock && firstBlock.querySelector('.block-content').classList.contains('text-3xl')) {
          // This is a title block
          const titleContent = firstBlock.querySelector('.block-content');
          title = titleContent.textContent.trim();
        }
        // Collect markdown from all blocks (skip the title block)
        const blocks = Array.from(this.container.querySelectorAll('.block'));
        const contentBlocks = title ? blocks.slice(1) : blocks;
        const documentMarkdown = contentBlocks.map(block => {
          const content = block.querySelector('.block-content');
          return content.textContent.trim();
        }).filter(text => text !== '').join('\n\n');

        // Save to server
        fetch('/pages/update', {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            page_id: pageId,
            title: title,
            content: documentMarkdown
          })
        })
        .then(response => response.json())
        .then(data => {
          if (data.status === 'success') {
            alert('Page saved successfully!');
            // Update PAGE_ID if it's a new page
            if (data.page_id) {
              window.PAGE_ID = data.page_id;
            }
          } else {
            alert('Failed to save page.');
          }
        })
        .catch(error => {
          console.error('Error:', error);
          alert('An error occurred while saving the page.');
        });
      }

      switchToEditMode(block) {
        if (!block) return;
        const content = block.querySelector('.block-content');
        const renderedContent = block.querySelector('.markdown-rendered');
        // Show original content, hide rendered content
        content.classList.remove('hidden');
        if (renderedContent) {
          renderedContent.classList.add('hidden');
        }
        content.focus();
        // Set this as the active block
        this.setActiveBlock(block);
        // Place cursor at the end
        this.placeCursorAtEnd(content);
      }

      switchToRenderMode(block) {
        const content = block.querySelector('.block-content');
        const renderedContent = block.querySelector('.markdown-rendered');
        // Only switch if there's actual content
        if (content.textContent.trim() && renderedContent) {
          // Render the markdown
          renderedContent.innerHTML = this.converter.makeHtml(content.textContent);
          // Special styling for code blocks
          if (content.classList.contains('code-block')) {
            renderedContent.classList.add('code-block');
          }
          // Hide content, show rendered
          content.classList.add('hidden');
          renderedContent.classList.remove('hidden');
        }
      }

      placeCursorAtEnd(element) {
        const range = document.createRange();
        const selection = window.getSelection();
        if (element.childNodes.length > 0) {
          const lastNode = element.childNodes[element.childNodes.length - 1];
          range.setStart(lastNode, lastNode.length || 0);
        } else {
          range.setStart(element, 0);
        }
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      }

      handleContentChange(block) {
        // Check for slash command
        const content = block.querySelector('.block-content');
        const text = content.textContent;
        if (text === '/') {
          this.showCommandMenu(block);
        } else if (!text.startsWith('/')) {
          this.hideCommandMenu();
          // Update the block type based on content
          this.updateBlockType(block);
        }
      }

      updateBlockType(block) {
        const content = block.querySelector('.block-content');
        const placeholder = block.querySelector('.block-placeholder');
        const text = content.textContent;
        // Reset content classes
        content.className = 'block-content';
        // Default placeholder
        placeholder.textContent = '‚ú¶';
        // Determine block type by content and apply appropriate styling
        if (text.startsWith('# ')) {
          // Heading 1
          content.classList.add('heading-1');
          placeholder.textContent = 'H1';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'h1');
        } else if (text.startsWith('## ')) {
          // Heading 2
          content.classList.add('heading-2');
          placeholder.textContent = 'H2';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'h2');
        } else if (text.startsWith('- [ ] ') || text.startsWith('- [x] ')) {
          // Todo list
          placeholder.textContent = '‚òê';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'todo');
        } else if (text.startsWith('```') && text.endsWith('```')) {
          // Code block
          content.classList.add('code-block');
          placeholder.textContent = '‚å®Ô∏è';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'code');
        } else if (text.startsWith('> ')) {
          // Quote
          content.classList.add('quote-block');
          placeholder.textContent = '‚ùù';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'quote');
        } else if (text.startsWith('- ')) {
          // Bullet list
          placeholder.textContent = '‚Ä¢';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'bullet');
        } else {
          // Normal text
          this.blockTypes.delete(block.id || '');
        }
      }

      assignBlockId(block) {
        // Generate and assign a unique ID to the block
        const id = 'block-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
        block.id = id;
        return id;
      }

      handleKeyDown(e, block) {
        // Slash key shows command menu
        if (e.key === '/') {
          const content = block.querySelector('.block-content');
          if (content.textContent === '') {
            this.showCommandMenu(block);
            return;
          }
        }
        // Enter key handling
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          // Get current content and block type
          const content = block.querySelector('.block-content');
          const text = content.textContent;
          const blockType = this.blockTypes.get(block.id || '');
          // Special handling for headings - don't lose the heading style
          if (blockType === 'h1' || blockType === 'h2') {
            // Create a new normal block after the heading
            const newBlock = this.addBlock(block);
            return;
          }
          // Special handling for todo lists
          if (text.match(/^- \[(x| )\] /)) {
            // Create a new todo item
            const newBlock = this.addBlock(block);
            const newContent = newBlock.querySelector('.block-content');
            newContent.textContent = '- [ ] ';
            // Update the block type
            this.updateBlockType(newBlock);
            // Position cursor
            this.placeCursorAtEnd(newContent);
            return;
          }
          // Special handling for bullet lists
          if (text.startsWith('- ')) {
            // Create a new list item
            const newBlock = this.addBlock(block);
            const newContent = newBlock.querySelector('.block-content');
            newContent.textContent = '- ';
            // Update the block type
            this.updateBlockType(newBlock);
            // Position cursor
            this.placeCursorAtEnd(newContent);
            return;
          }
          // Special handling for code blocks - add a newline instead
          if (content.classList.contains('code-block') && !text.endsWith('```')) {
            document.execCommand('insertText', false, '\n');
            return;
          }
          // Create a new block with the same type if applicable
          const newBlock = this.addBlock(block);
          // If the current block is a heading, create a normal block.
          // Otherwise, maintain the same block type if applicable.
          if (blockType && blockType !== 'h1' && blockType !== 'h2') {
            const newContent = newBlock.querySelector('.block-content');
            switch(blockType) {
              case 'todo':
                newContent.textContent = '- [ ] ';
                break;
              case 'bullet':
                newContent.textContent = '- ';
                break;
              case 'quote':
                newContent.textContent = '> ';
                break;
            }
            // Update the new block's type
            this.updateBlockType(newBlock);
          }
          return;
        }
        // Backspace on empty block
        if (e.key === 'Backspace') {
          const content = block.querySelector('.block-content');
          if (content.textContent === '' && this.container.children.length > 1) {
            e.preventDefault();
            this.deleteBlock(block);
            return;
          }
        }
        // Tab key for code blocks
        if (e.key === 'Tab' && block.querySelector('.block-content').classList.contains('code-block')) {
          e.preventDefault();
          document.execCommand('insertText', false, '    ');
          return;
        }
      }

      showCommandMenu(block) {
        const rect = block.getBoundingClientRect();
        this.commandMenu.style.display = 'block';
        this.commandMenu.style.top = `${rect.bottom + window.scrollY}px`;
        this.commandMenu.style.left = `${rect.left + window.scrollX}px`;
        // Store reference to the active block
        this.activeBlock = block;
      }

      hideCommandMenu() {
        this.commandMenu.style.display = 'none';
      }

      applyCommand(type) {
        if (!this.activeBlock) return;
        const content = this.activeBlock.querySelector('.block-content');
        let prefix = '';
        // Page creation handling ‚Äì call the global function and store the current block reference
        if (type === 'page') {
          this.hideCommandMenu();
          window.currentBlock = this.activeBlock;
          createNewPage();
          return;
        }
        switch(type) {
          case 'h1':
            prefix = '# ';
            content.className = 'block-content heading-1';
            break;
          case 'h2':
            prefix = '## ';
            content.className = 'block-content heading-2';
            break;
          case 'todo':
            prefix = '- [ ] ';
            break;
          case 'code':
            prefix = '```\n\n```';
            content.className = 'block-content code-block';
            break;
          case 'quote':
            prefix = '> ';
            content.className = 'block-content quote-block';
            break;
          case 'bullet':
            prefix = '- ';
            break;
        }
        // Remove the '/' command trigger
        content.textContent = '';
        // Insert markdown prefix
        content.textContent = prefix;
        // Update the block's placeholder and store its type
        this.updateBlockType(this.activeBlock);
        // Explicitly set block type in the map
        this.blockTypes.set(this.activeBlock.id || this.assignBlockId(this.activeBlock), type);
        // Focus the content
        content.focus();
        // Place cursor at the appropriate position
        if (type === 'code') {
          // Place cursor between the backticks
          this.placeCursorAtPosition(content, 4); // After "```\n"
        } else {
          // Place cursor at end of prefix
          this.placeCursorAtPosition(content, prefix.length);
        }
        this.hideCommandMenu();
      }

      placeCursorAtPosition(element, position) {
        const range = document.createRange();
        const selection = window.getSelection();
        if (element.firstChild) {
          const textNode = element.firstChild;
          const pos = Math.min(position, textNode.length);
          range.setStart(textNode, pos);
        } else {
          const textNode = document.createTextNode(element.textContent);
          element.appendChild(textNode);
          const pos = Math.min(position, textNode.length);
          range.setStart(textNode, pos);
        }
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      }

      addBlock(afterBlock = null, focus = true) {
        const block = document.createElement('div');
        const id = 'block-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
        block.id = id;
        block.className = 'block relative';
        block.innerHTML = `
          <div class="block-placeholder"> ‚ú¶ </div>
          <div class="block-content" contenteditable="true"></div>
          <div class="markdown-rendered prose hidden"></div>
        `;
        if (afterBlock) {
          if (afterBlock.nextSibling) {
            this.container.insertBefore(block, afterBlock.nextSibling);
          } else {
            this.container.appendChild(block);
          }
        } else {
          this.container.appendChild(block);
        }
        // Setup event listeners for this block
        this.setupBlockEventListeners(block);
        // Focus the new block if needed
        if (focus) {
          const content = block.querySelector('.block-content');
          content.focus();
          this.setActiveBlock(block);
        }
        return block;
      }

      deleteBlock(block) {
        const previousBlock = block.previousElementSibling;
        this.blockTypes.delete(block.id || '');
        this.container.removeChild(block);
        if (previousBlock) {
          this.switchToEditMode(previousBlock);
        }
      }
    }
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const editorContainer = document.getElementById('editor');
      window.editor = new Slipstream(editorContainer);
      // Attach the event listener to a button (if exists)
      document.getElementById('new-page-btn')?.addEventListener('click', createNewPage);
    });

    function createNewPage() {
      // Create a modal for page creation
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
      modal.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-lg max-w-md w-full">
          <h2 class="text-xl font-bold mb-4">Create New Page</h2>
          <form id="create-page-form">
            <div class="mb-4">
              <label class="block text-sm font-medium mb-1" for="page-title">Page Title:</label>
              <input class="w-full p-2 border rounded" type="text" id="page-title" name="title" required>
            </div>
            <div class="flex justify-end gap-2">
              <button type="button" id="cancel-page" class="px-4 py-2 bg-gray-200 rounded">Cancel</button>
              <button type="submit" class="px-4 py-2 bg-blue-500 text-white rounded">Create</button>
            </div>
          </form>
        </div>
      `;
      document.body.appendChild(modal);
      // Set focus on the title input
      setTimeout(() => {
        document.getElementById('page-title').focus();
      }, 100);
      // Handle form submission
      document.getElementById('create-page-form').addEventListener('submit', (e) => {
        e.preventDefault();
        const title = document.getElementById('page-title').value.trim();
        if (!title) return;
        fetch('/pages/create', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            title: title,
            content: `# ${title}`,
            parent_id: 0
          })
        })
        .then(response => response.json())
        .then(data => {
          if (data.status === 'success') {
            document.body.removeChild(modal);
            // If a current block was saved when the command was triggered, update it with a link icon
            if (window.currentBlock) {
              const placeholder = window.currentBlock.querySelector('.block-placeholder');
              const linkIcon = document.createElement('a');
              linkIcon.href = `/page/${data.page_id}`;
              linkIcon.innerHTML = 'üìÑ';
              linkIcon.title = 'Go to the new page';
              placeholder.innerHTML = '';
              placeholder.appendChild(linkIcon);
            }
            if (confirm('Page created! Do you want to open it now?')) {
              window.location.href = `/pages/${data.page_id}`;
            }
          } else {
            alert('Failed to create page.');
          }
        })
        .catch(error => {
          console.error('Error:', error);
          alert('An error occurred while creating the page.');
        });
      });
      // Handle cancel button
      document.getElementById('cancel-page').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
    }
  </script>
</body>
</html>
