<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Notion-like Editor</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
  <link rel="stylesheet" href="styles.css">
</head>

<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    line-height: 1.6;
  }
  #editor-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 40px 20px;
  }
  .block {
    position: relative;
    margin-bottom: 5px;
    transition: background-color 0.1s;
  }
  .block:hover {
    background-color: rgba(55, 53, 47, 0.08);
    border-radius: 3px;
  }
  .block-content {
    width: 100%;
    outline: none;
    padding: 3px 2px;
    min-height: 30px;
    white-space: pre-wrap;
  }
  .block-content:empty:before {
    content: 'Type / for commands...';
    color: #888;
    opacity: 0.5;
  }
  .block-content.hidden {
    position: absolute;
    opacity: 0;
    pointer-events: none;
  }
  .markdown-rendered {
    width: 100%;
    padding: 3px 2px;
    cursor: text;
    min-height: 30px;
  }
  .markdown-rendered img {
    max-width: 100%;
    height: auto;
  }
  .block-placeholder {
    position: absolute;
    left: -30px;
    color: #888;
    opacity: 0;
    cursor: pointer;
    transition: opacity 0.2s;
  }
  .block:hover .block-placeholder {
    opacity: 0.5;
  }
  .block.active .block-placeholder {
    opacity: 1;
  }
  .command-menu {
    position: absolute;
    background: white;
    border: 1px solid #ddd;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    z-index: 10;
    min-width: 200px;
    border-radius: 4px;
    display: none;
    overflow: hidden;
  }
  .command-item {
    padding: 8px 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background-color 0.2s;
  }
  .command-item:hover {
    background-color: #f0f0f0;
  }
  .command-item-icon {
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #888;
  }
  .command-item-text {
    display: flex;
    flex-direction: column;
  }
  .command-item-title {
    font-weight: 500;
  }
  .command-item-description {
    font-size: 12px;
    color: #888;
  }
  #save-button {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
  .code-block {
    background-color: rgba(135, 131, 120, 0.15);
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
    padding: 16px;
    border-radius: 4px;
    tab-size: 2;
  }
  .markdown-rendered.code-block pre {
    margin: 0;
  }
  .markdown-rendered.code-block code {
    background: transparent;
    padding: 0;
  }
  .todo-item {
    display: flex;
    align-items: flex-start;
    margin: 0;
    padding: 0;
  }
  .todo-checkbox {
    margin-right: 8px;
    margin-top: 4px;
    cursor: pointer;
  }
  .heading-1 {
    font-size: 1.875rem;
    font-weight: 600;
    margin-top: 32px;
    margin-bottom: 4px;
  }
  .heading-2 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-top: 24px;
    margin-bottom: 4px;
  }
  .quote-block {
    border-left: 3px solid rgba(55, 53, 47, 0.16);
    padding-left: 14px;
    font-style: italic;
    color: rgba(55, 53, 47, 0.8);
  }
  .markdown-rendered h1, .markdown-rendered h2 {
    margin-top: 0;
    margin-bottom: 0;
  }
  /* Added rules for rendered headings */
  .markdown-rendered h1 {
    font-size: 1.875rem;
    font-weight: 600;
    margin-top: 32px;
    margin-bottom: 4px;
  }
  .markdown-rendered h2 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-top: 24px;
    margin-bottom: 4px;
  }
  .markdown-rendered ul {
    margin-top: 0;
    margin-bottom: 0;
    padding-left: 24px;
  }
  .markdown-rendered blockquote {
    margin: 0;
    padding-left: 14px;
    border-left: 3px solid rgba(55, 53, 47, 0.16);
    color: rgba(55, 53, 47, 0.8);
  }
  .markdown-rendered pre {
    background-color: rgba(135, 131, 120, 0.15);
    padding: 16px;
    border-radius: 4px;
    margin: 0;
  }
  .markdown-rendered code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
    background-color: rgba(135, 131, 120, 0.15);
    padding: 0.2em 0.4em;
    border-radius: 3px;
    font-size: 85%;
  }
  .markdown-rendered pre > code {
    background-color: transparent;
    padding: 0;
  }
  .markdown-rendered strong {
    font-weight: 600;
  }
  .markdown-rendered em {
    font-style: italic;
  }
  .markdown-rendered p {
    margin-top: 0;
    margin-bottom: 0;
  }
  .markdown-rendered input[type="checkbox"] {
    margin-right: 6px;
  }
  
</style>

<body>
  <div id="editor-container">
    <div id="editor">
      <!-- Blocks will be dynamically added here -->
    </div>
  </div>

  <button id="save-button">Save Document</button>

  <div id="command-menu" class="command-menu">
    <div class="command-item" data-type="h1">
      <div class="command-item-icon">H1</div>
      <div class="command-item-text">
        <div class="command-item-title">Heading 1</div>
        <div class="command-item-description">Big section heading</div>
      </div>
    </div>
    <div class="command-item" data-type="h2">
      <div class="command-item-icon">H2</div>
      <div class="command-item-text">
        <div class="command-item-title">Heading 2</div>
        <div class="command-item-description">Medium section heading</div>
      </div>
    </div>
    <div class="command-item" data-type="todo">
      <div class="command-item-icon">‚òê</div>
      <div class="command-item-text">
        <div class="command-item-title">To-do list</div>
        <div class="command-item-description">Track tasks with a to-do list</div>
      </div>
    </div>
    <div class="command-item" data-type="code">
      <div class="command-item-icon">‚å®Ô∏è</div>
      <div class="command-item-text">
        <div class="command-item-title">Code</div>
        <div class="command-item-description">Add code with syntax highlighting</div>
      </div>
    </div>
    <div class="command-item" data-type="quote">
      <div class="command-item-icon">‚ùù</div>
      <div class="command-item-text">
        <div class="command-item-title">Quote</div>
        <div class="command-item-description">Capture a quote</div>
      </div>
    </div>
    <div class="command-item" data-type="bullet">
      <div class="command-item-icon">‚Ä¢</div>
      <div class="command-item-text">
        <div class="command-item-title">Bullet List</div>
        <div class="command-item-description">Create a simple bullet list</div>
      </div>
    </div>
    <div class="command-item" data-type="page">
      <div class="command-item-icon">üìÑ</div>
      <div class="command-item-text">
        <div class="command-item-title">New Page</div>
        <div class="command-item-description">Create a new linked page</div>
      </div>
    </div>
  </div>

  <script th:inline="javascript">
    window.PAGE_TITLE = /*[[${title}]]*/ "";
    window.PAGE_CONTENT = /*[[${content}]]*/ "";
    /*]]>*/
</script>
  <!-- Include the NotionLikeEditor class -->
  <script>
    class Slipstream {
      constructor(container) {
        this.container = container;
        this.converter = new showdown.Converter({
          tables: true,
          tasklists: true,
          strikethrough: true,
          literalMidWordUnderscores: true,
          simpleLineBreaks: true
        });
        this.commandMenu = document.getElementById('command-menu');
        this.activeBlock = null;
        this.isInEditMode = true;
        this.blockTypes = new Map(); // Store block types for persistence

        this.initializeEditor();
        this.setupEventListeners();
      }

      initializeEditor() {
        // Check if we have pre-loaded title and content
        const pageTitle = window.PAGE_TITLE || '';
        const pageContent = window.PAGE_CONTENT || '';

        // Clear the container first
        this.container.innerHTML = '';

        // Add title block if we have a title
        if (pageTitle) {
          this.addTitleBlock(pageTitle);
        }

        // Add content blocks if we have content
        if (pageContent) {
          this.loadContentFromMarkdown(pageContent);
        } else {
          // Create initial empty block if there's no content
          this.addBlock();
        }

        // Setup save button
        document.getElementById('save-button').addEventListener('click', () => this.saveDocument());
      }

      addTitleBlock(title) {
        const titleBlock = document.createElement('div');
        titleBlock.className = 'block relative mb-6';
        titleBlock.innerHTML = `
          <div class="block-placeholder">üìÑ</div>
          <div class="block-content text-3xl font-bold" contenteditable="true">${title}</div>
          <div class="markdown-rendered prose text-3xl font-bold hidden"></div>
        `;

        this.container.appendChild(titleBlock);

        // Set up event listeners for this block
        this.setupBlockEventListeners(titleBlock);
      }

      loadContentFromMarkdown(markdown) {
        // Split content by double newlines to create blocks
        const blocks = markdown.split(/\n\n+/);
        blocks.forEach(blockContent => {
          if (blockContent.trim()) {
            const block = this.addBlock(null, false);
            const content = block.querySelector('.block-content');
            // Set the content
            content.textContent = blockContent;
            // Update block type based on content
            this.updateBlockType(block);
            // Switch to render mode for the block
            this.switchToRenderMode(block);
          }
        });
      }

      setupEventListeners() {
        // Global keydown event
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            this.hideCommandMenu();
          }
        });

        // Command menu listeners
        this.commandMenu.addEventListener('click', (e) => {
          const item = e.target.closest('.command-item');
          if (item) {
            this.applyCommand(item.dataset.type);
          }
        });

        // Click outside to hide command menu
        document.addEventListener('click', (e) => {
          if (!this.commandMenu.contains(e.target) && !e.target.closest('.block-content')) {
            this.hideCommandMenu();
          }
        });
      }

      setupBlockEventListeners(block) {
        const content = block.querySelector('.block-content');
        const renderedContent = block.querySelector('.markdown-rendered');

        // Input event for content changes
        content.addEventListener('input', () => {
          this.handleContentChange(block);
        });

        // Keydown events for special handling
        content.addEventListener('keydown', (e) => {
          this.handleKeyDown(e, block);
        });

        // Focus handling
        content.addEventListener('focus', () => {
          this.setActiveBlock(block);
        });

        // Handle clicks on rendered content to switch to edit mode
        if (renderedContent) {
          renderedContent.addEventListener('click', () => {
            this.switchToEditMode(block);
          });
        }

        // Handle paste events
        content.addEventListener('paste', (e) => {
          this.handlePaste(e, block);
        });

        // Handle blur to switch to render mode
        content.addEventListener('blur', () => {
          // Only switch if not focused on command menu
          if (!this.commandMenu.contains(document.activeElement)) {
            this.switchToRenderMode(block);
          }
        });
      }

      setActiveBlock(block) {
        // Remove active class from all blocks
        const allBlocks = this.container.querySelectorAll('.block');
        allBlocks.forEach(b => b.classList.remove('active'));
        // Add active class to current block
        block.classList.add('active');
        this.activeBlock = block;
      }

      handlePaste(e, block) {
        const target = e.target;
        if (!target.classList.contains('block-content')) return;
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf("image") !== -1) {
            const blob = items[i].getAsFile();
            const reader = new FileReader();
            reader.onload = (event) => {
              const content = block.querySelector('.block-content');
              // Insert markdown image syntax
              const imageMarkdown = `![Pasted Image](${event.target.result})`;
              content.textContent += imageMarkdown;
              // Update the block
              this.handleContentChange(block);
            };
            reader.readAsDataURL(blob);
            // Prevent default paste
            e.preventDefault();
            break;
          }
        }
      }

      saveDocument() {
    // Extract page ID from the current URL (supports numeric & alphanumeric IDs)
    const pageIdMatch = window.location.pathname.match(/\/pages\/([^/]+)/);
    const pageId = pageIdMatch ? String(pageIdMatch[1]) : null;

    if (!pageId) {
        alert('Could not determine page ID.');
        return;
    }

    // Get title from the first block if it exists
    const firstBlock = this.container.querySelector('.block');
    let title = '';

    if (firstBlock) {
        const titleContent = firstBlock.querySelector('.block-content');
        if (titleContent && titleContent.classList.contains('text-3xl')) {
            // This is a title block
            title = titleContent.textContent.trim();
        }
    }

    // Collect markdown from all blocks (excluding the title block)
    const blocks = Array.from(this.container.querySelectorAll('.block'));
    const contentBlocks = title ? blocks.slice(1) : blocks;

    const documentMarkdown = contentBlocks.map(block => {
        const content = block.querySelector('.block-content');
        return content ? content.textContent : '';
    }).filter(text => text !== '').join('\n\n');

    // Save to server using the correct URL format
    fetch(`/api/pages/${encodeURIComponent(pageId)}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'text/plain' },
    body: documentMarkdown
})
.then(response => response.text())  // Change .json() to .text()
.then(data => {
    console.log("Response from server:", data);
    alert('Page saved successfully!');
})
.catch(error => {
    console.error('Error:', error);
    alert('An error occurred while saving the page.');
});

}

      switchToEditMode(block) {
        if (!block) return;
        const content = block.querySelector('.block-content');
        const renderedContent = block.querySelector('.markdown-rendered');
        // Show original content, hide rendered content
        content.classList.remove('hidden');
        if (renderedContent) {
          renderedContent.classList.add('hidden');
        }
        content.focus();
        // Set this as the active block
        this.setActiveBlock(block);
        // Place cursor at the end
        this.placeCursorAtEnd(content);
      }

      switchToRenderMode(block) {
        const content = block.querySelector('.block-content');
        const renderedContent = block.querySelector('.markdown-rendered');
        // Only switch if there's actual content
        if (content.textContent.trim() && renderedContent) {
          // Render the markdown
          renderedContent.innerHTML = this.converter.makeHtml(content.textContent);
          // Special styling for code blocks
          if (content.classList.contains('code-block')) {
            renderedContent.classList.add('code-block');
          }
          // Hide content, show rendered
          content.classList.add('hidden');
          renderedContent.classList.remove('hidden');
        }
      }

      placeCursorAtEnd(element) {
        const range = document.createRange();
        const selection = window.getSelection();
        if (element.childNodes.length > 0) {
          const lastNode = element.childNodes[element.childNodes.length - 1];
          range.setStart(lastNode, lastNode.length || 0);
        } else {
          range.setStart(element, 0);
        }
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      }

      handleContentChange(block) {
        // Check for slash command
        const content = block.querySelector('.block-content');
        const text = content.textContent;
        if (text === '/') {
          this.showCommandMenu(block);
        } else if (!text.startsWith('/')) {
          this.hideCommandMenu();
          // Update the block type based on content
          this.updateBlockType(block);
        }
      }

      updateBlockType(block) {
        const content = block.querySelector('.block-content');
        const placeholder = block.querySelector('.block-placeholder');
        const text = content.textContent;
        // Reset content classes
        content.className = 'block-content';
        // Default placeholder
        placeholder.textContent = '‚ú¶';
        // Determine block type by content and apply appropriate styling
        if (text.startsWith('# ')) {
          // Heading 1
          content.classList.add('heading-1');
          placeholder.textContent = 'H1';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'h1');
        } else if (text.startsWith('## ')) {
          // Heading 2
          content.classList.add('heading-2');
          placeholder.textContent = 'H2';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'h2');
        } else if (text.startsWith('- [ ] ') || text.startsWith('- [x] ')) {
          // Todo list
          placeholder.textContent = '‚òê';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'todo');
        } else if (text.startsWith('```') && text.endsWith('```')) {
          // Code block
          content.classList.add('code-block');
          placeholder.textContent = '‚å®Ô∏è';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'code');
        } else if (text.startsWith('> ')) {
          // Quote
          content.classList.add('quote-block');
          placeholder.textContent = '‚ùù';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'quote');
        } else if (text.startsWith('- ')) {
          // Bullet list
          placeholder.textContent = '‚Ä¢';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'bullet');
        } else {
          // Normal text
          this.blockTypes.delete(block.id || '');
        }
      }

      assignBlockId(block) {
        // Generate and assign a unique ID to the block
        const id = 'block-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
        block.id = id;
        return id;
      }

      handleKeyDown(e, block) {
        // Slash key shows command menu
        if (e.key === '/') {
          const content = block.querySelector('.block-content');
          if (content.textContent === '') {
            this.showCommandMenu(block);
            return;
          }
        }
        // Enter key handling
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          // Get current content and block type
          const content = block.querySelector('.block-content');
          const text = content.textContent;
          const blockType = this.blockTypes.get(block.id || '');
          // Special handling for headings - don't lose the heading style
          if (blockType === 'h1' || blockType === 'h2') {
            // Create a new normal block after the heading
            const newBlock = this.addBlock(block);
            return;
          }
          // Special handling for todo lists
          if (text.match(/^- \[(x| )\] /)) {
            // Create a new todo item
            const newBlock = this.addBlock(block);
            const newContent = newBlock.querySelector('.block-content');
            newContent.textContent = '- [ ] ';
            // Update the block type
            this.updateBlockType(newBlock);
            // Position cursor
            this.placeCursorAtEnd(newContent);
            return;
          }
          // Special handling for bullet lists
          if (text.startsWith('- ')) {
            // Create a new list item
            const newBlock = this.addBlock(block);
            const newContent = newBlock.querySelector('.block-content');
            newContent.textContent = '- ';
            // Update the block type
            this.updateBlockType(newBlock);
            // Position cursor
            this.placeCursorAtEnd(newContent);
            return;
          }
          // Special handling for code blocks - add a newline instead
          if (content.classList.contains('code-block') && !text.endsWith('```')) {
            document.execCommand('insertText', false, '\n');
            return;
          }
          // Create a new block with the same type if applicable
          const newBlock = this.addBlock(block);
          // If the current block is a heading, create a normal block.
          // Otherwise, maintain the same block type if applicable.
          if (blockType && blockType !== 'h1' && blockType !== 'h2') {
            const newContent = newBlock.querySelector('.block-content');
            switch(blockType) {
              case 'todo':
                newContent.textContent = '- [ ] ';
                break;
              case 'bullet':
                newContent.textContent = '- ';
                break;
              case 'quote':
                newContent.textContent = '> ';
                break;
            }
            // Update the new block's type
            this.updateBlockType(newBlock);
          }
          return;
        }
        // Backspace on empty block
        if (e.key === 'Backspace') {
          const content = block.querySelector('.block-content');
          if (content.textContent === '' && this.container.children.length > 1) {
            e.preventDefault();
            this.deleteBlock(block);
            return;
          }
        }
        // Tab key for code blocks
        if (e.key === 'Tab' && block.querySelector('.block-content').classList.contains('code-block')) {
          e.preventDefault();
          document.execCommand('insertText', false, '    ');
          return;
        }
      }

      showCommandMenu(block) {
        const rect = block.getBoundingClientRect();
        this.commandMenu.style.display = 'block';
        this.commandMenu.style.top = `${rect.bottom + window.scrollY}px`;
        this.commandMenu.style.left = `${rect.left + window.scrollX}px`;
        // Store reference to the active block
        this.activeBlock = block;
      }

      hideCommandMenu() {
        this.commandMenu.style.display = 'none';
      }

      applyCommand(type) {
        if (!this.activeBlock) return;
        const content = this.activeBlock.querySelector('.block-content');
        let prefix = '';
        // Page creation handling ‚Äì call the global function and store the current block reference
        if (type === 'page') {
          this.hideCommandMenu();
          window.currentBlock = this.activeBlock;
          createNewPage();
          return;
        }
        switch(type) {
          case 'h1':
            prefix = '# ';
            content.className = 'block-content heading-1';
            break;
          case 'h2':
            prefix = '## ';
            content.className = 'block-content heading-2';
            break;
          case 'todo':
            prefix = '- [ ] ';
            break;
          case 'code':
            prefix = '```\n\n```';
            content.className = 'block-content code-block';
            break;
          case 'quote':
            prefix = '> ';
            content.className = 'block-content quote-block';
            break;
          case 'bullet':
            prefix = '- ';
            break;
        }
        // Remove the '/' command trigger
        content.textContent = '';
        // Insert markdown prefix
        content.textContent = prefix;
        // Update the block's placeholder and store its type
        this.updateBlockType(this.activeBlock);
        // Explicitly set block type in the map
        this.blockTypes.set(this.activeBlock.id || this.assignBlockId(this.activeBlock), type);
        // Focus the content
        content.focus();
        // Place cursor at the appropriate position
        if (type === 'code') {
          // Place cursor between the backticks
          this.placeCursorAtPosition(content, 4); // After "```\n"
        } else {
          // Place cursor at end of prefix
          this.placeCursorAtPosition(content, prefix.length);
        }
        this.hideCommandMenu();
      }

      placeCursorAtPosition(element, position) {
        const range = document.createRange();
        const selection = window.getSelection();
        if (element.firstChild) {
          const textNode = element.firstChild;
          const pos = Math.min(position, textNode.length);
          range.setStart(textNode, pos);
        } else {
          const textNode = document.createTextNode(element.textContent);
          element.appendChild(textNode);
          const pos = Math.min(position, textNode.length);
          range.setStart(textNode, pos);
        }
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      }

      addBlock(afterBlock = null, focus = true) {
        const block = document.createElement('div');
        const id = 'block-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
        block.id = id;
        block.className = 'block relative';
        block.innerHTML = `
          <div class="block-placeholder"> ‚ú¶ </div>
          <div class="block-content" contenteditable="true"></div>
          <div class="markdown-rendered prose hidden"></div>
        `;
        if (afterBlock) {
          if (afterBlock.nextSibling) {
            this.container.insertBefore(block, afterBlock.nextSibling);
          } else {
            this.container.appendChild(block);
          }
        } else {
          this.container.appendChild(block);
        }
        // Setup event listeners for this block
        this.setupBlockEventListeners(block);
        // Focus the new block if needed
        if (focus) {
          const content = block.querySelector('.block-content');
          content.focus();
          this.setActiveBlock(block);
        }
        return block;
      }

      deleteBlock(block) {
        const previousBlock = block.previousElementSibling;
        this.blockTypes.delete(block.id || '');
        this.container.removeChild(block);
        if (previousBlock) {
          this.switchToEditMode(previousBlock);
        }
      }
    }
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const editorContainer = document.getElementById('editor');
      window.editor = new Slipstream(editorContainer);
      // Attach the event listener to a button (if exists)
      document.getElementById('new-page-btn')?.addEventListener('click', createNewPage);
    });

    function createNewPage() {
      // Create a modal for page creation
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
      modal.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-lg max-w-md w-full">
          <h2 class="text-xl font-bold mb-4">Create New Page</h2>
          <form id="create-page-form">
            <div class="mb-4">
              <label class="block text-sm font-medium mb-1" for="page-title">Page Title:</label>
              <input class="w-full p-2 border rounded" type="text" id="page-title" name="title" required>
            </div>
            <div class="flex justify-end gap-2">
              <button type="button" id="cancel-page" class="px-4 py-2 bg-gray-200 rounded">Cancel</button>
              <button type="submit" class="px-4 py-2 bg-blue-500 text-white rounded">Create</button>
            </div>
          </form>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Set focus on the title input
      setTimeout(() => {
        document.getElementById('page-title').focus();
      }, 100);
      
      // Handle form submission
      document.getElementById('create-page-form').addEventListener('submit', (e) => {
        e.preventDefault();
        const title = document.getElementById('page-title').value.trim();
        const pageIdMatch = window.location.pathname.match(/\/pages\/([^/]+)/);
        const pageId = pageIdMatch ? String(pageIdMatch[1]) : null;
        console.log("Page ID:", pageId);
        if (!title) return;
        
        fetch('/api/pages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            title: title,
            content: `# ${title}`,
            parentPageId: pageId, // Changed from parentPage to parentPageId to match backend
            type: 'content' // Always create as content page initially
          })
        })
        .then(response => response.text())
        .then(data => {
          document.body.removeChild(modal);
          
          // If a current block was saved when the command was triggered, update it with a link icon
          if (window.currentBlock) {
            // Update placeholder with link icon
            const placeholder = window.currentBlock.querySelector('.block-placeholder');
            const linkIcon = document.createElement('a');
            linkIcon.href = `/pages/${data}`;
            linkIcon.innerHTML = 'üìÑ';
            linkIcon.title = 'Go to the new page';
            placeholder.innerHTML = '';
            placeholder.appendChild(linkIcon);
            
            // Update content with markdown link
            const content = window.currentBlock.querySelector('.block-content');
            content.textContent = `[üìÑ ${title}](view/pages/${data})`;
            
            // Update the block type and rendered view
            window.editor.updateBlockType(window.currentBlock);
            window.editor.switchToRenderMode(window.currentBlock);
        }
          
          if (confirm('Page created! Do you want to open it now?')) {
            window.location.href = `view/pages/${data}`; // Changed to directly use the returned pageId
          }
        })
        .catch(error => {
          console.error('Error:', error);
          alert('An error occurred while creating the page.');
        });
      });
      
      // Handle cancel button
      document.getElementById('cancel-page').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
    }
  </script>
</body>
</html>
