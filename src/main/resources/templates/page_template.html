<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title th:text="${title} ?: 'Slipstream Page'">Notion-like Editor</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/showdown/2.1.0/showdown.min.js"></script>
  <link rel="stylesheet" href="/styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
</head>

<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    line-height: 1.6;
  }
  #editor-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 40px 20px;
  }
  .block {
    position: relative;
    margin-bottom: 5px;
    transition: background-color 0.1s;
  }
  .block:hover {
    background-color: rgba(55, 53, 47, 0.08);
    border-radius: 3px;
  }
  .block-content {
    width: 100%;
    outline: none;
    padding: 3px 2px;
    min-height: 30px;
    white-space: pre-wrap;
  }
  .block-content:empty:before {
    content: 'Type / for commands...';
    color: #888;
    opacity: 0.5;
  }
  .block-content.hidden {
    position: absolute;
    opacity: 0;
    pointer-events: none;
  }
  .markdown-rendered {
    width: 100%;
    padding: 3px 2px;
    cursor: text;
    min-height: 30px;
  }
  .markdown-rendered img {
    max-width: 100%;
    height: auto;
  }
  .block-placeholder {
    position: absolute;
    left: -30px;
    color: #888;
    opacity: 0;
    cursor: pointer;
    transition: opacity 0.2s;
  }
  .block:hover .block-placeholder {
    opacity: 0.5;
  }
  .block.active .block-placeholder {
    opacity: 1;
  }
  .command-menu {
    position: absolute;
    background: white;
    border: 1px solid #ddd;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    z-index: 10;
    min-width: 200px;
    border-radius: 4px;
    display: none;
    overflow: hidden;
  }
  .command-item {
    padding: 8px 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background-color 0.2s;
  }
  .command-item:hover {
    background-color: #f0f0f0;
  }
  .command-item-icon {
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #888;
  }
  .command-item-text {
    display: flex;
    flex-direction: column;
  }
  .command-item-title {
    font-weight: 500;
  }
  .command-item-description {
    font-size: 12px;
    color: #888;
  }
  #save-button {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
  .code-block {
    background-color: rgba(135, 131, 120, 0.15);
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
    padding: 16px;
    border-radius: 4px;
    tab-size: 2;
  }
  .markdown-rendered.code-block pre {
    margin: 0;
  }
  .markdown-rendered.code-block code {
    background: transparent;
    padding: 0;
  }
  .todo-item {
    display: flex;
    align-items: flex-start;
    margin: 0;
    padding: 0;
  }
  .todo-checkbox {
    margin-right: 8px;
    margin-top: 4px;
    cursor: pointer;
  }
  .heading-1 {
    font-size: 1.875rem;
    font-weight: 600;
    margin-top: 32px;
    margin-bottom: 4px;
  }
  .heading-2 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-top: 24px;
    margin-bottom: 4px;
  }
  .quote-block {
    border-left: 3px solid rgba(55, 53, 47, 0.16);
    padding-left: 14px;
    font-style: italic;
    color: rgba(55, 53, 47, 0.8);
  }
  .markdown-rendered h1, .markdown-rendered h2 {
    margin-top: 0;
    margin-bottom: 0;
  }
  /* Added rules for rendered headings */
  .markdown-rendered h1 {
    font-size: 1.875rem;
    font-weight: 600;
    margin-top: 32px;
    margin-bottom: 4px;
  }
  .markdown-rendered h2 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-top: 24px;
    margin-bottom: 4px;
  }
  .markdown-rendered ul {
    margin-top: 0;
    margin-bottom: 0;
    padding-left: 24px;
  }
  .markdown-rendered blockquote {
    margin: 0;
    padding-left: 14px;
    border-left: 3px solid rgba(55, 53, 47, 0.16);
    color: rgba(55, 53, 47, 0.8);
  }
  .markdown-rendered pre {
    background-color: rgba(135, 131, 120, 0.15);
    padding: 16px;
    border-radius: 4px;
    margin: 0;
  }
  .markdown-rendered code {
    font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
    background-color: rgba(135, 131, 120, 0.15);
    padding: 0.2em 0.4em;
    border-radius: 3px;
    font-size: 85%;
  }
  .markdown-rendered pre > code {
    background-color: transparent;
    padding: 0;
  }
  .markdown-rendered strong {
    font-weight: 600;
  }
  .markdown-rendered em {
    font-style: italic;
  }
  .markdown-rendered p {
    margin-top: 0;
    margin-bottom: 0;
  }
  .markdown-rendered input[type="checkbox"] {
    margin-right: 6px;
  }
  #presence-icons {
    position: absolute;
    top: 10px;
    right: 120px;
    display: flex;
    gap: 5px;
  }
  .presence-icon {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    background-color: #ccc;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: bold;
    border: 1px solid white;
    box-shadow: 0 0 3px rgba(0,0,0,0.3);
    cursor: default;
  }
  #share-button {
    position: absolute;
    top: 10px;
    right: 20px;
    padding: 8px 15px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }
  #share-button:hover {
    background-color: #0056b3;
  }
  .modal {
    display: none;
    position: fixed;
    z-index: 100;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.4);
    padding-top: 60px;
  }
  .modal-content {
    background-color: #fefefe;
    margin: 5% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    max-width: 500px;
    border-radius: 5px;
  }
  .close-button {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
  }
  .close-button:hover,
  .close-button:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
  }
  #share-email-input { width: calc(100% - 130px); margin-right: 5px; }
  #share-access-select { width: 120px; margin-right: 5px; }
  #add-share-button { width: auto; }
  #shared-users-list { list-style: none; padding: 0; margin-top: 15px; }
  #shared-users-list li { display: flex; justify-content: space-between; align-items: center; padding: 5px 0; border-bottom: 1px solid #eee; }
  .remove-share-button { background: #dc3545; color: white; border: none; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-size: 12px; }
  /* Style for sub-page blocks to visually distinguish if needed */
  .block[data-subpage-id] {
    /* Example: slightly different background or border */
    /* background-color: #f0f8ff; */
  }
  .block[data-subpage-id] .block-content {
    /* Prevent direct editing appearance if desired, though blur handles restoration */
    /* cursor: default; */
  }
</style>

<body>
  <div id="presence-icons">
    <!-- Icons will be added dynamically -->
  </div>

  <button id="share-button" th:if="${canEdit}">Share</button>

  <div id="editor-container">
    <div id="editor">
      <!-- Blocks will be dynamically added here -->
    </div>
  </div>

  <button id="save-button" th:if="${canEdit}">Save Document</button>

  <div id="command-menu" class="command-menu">
    <div class="command-item" data-type="h1">
      <div class="command-item-icon">H1</div>
      <div class="command-item-text">
        <div class="command-item-title">Heading 1</div>
        <div class="command-item-description">Big section heading</div>
      </div>
    </div>
    <div class="command-item" data-type="h2">
      <div class="command-item-icon">H2</div>
      <div class="command-item-text">
        <div class="command-item-title">Heading 2</div>
        <div class="command-item-description">Medium section heading</div>
      </div>
    </div>
    <div class="command-item" data-type="todo">
      <div class="command-item-icon">‚òê</div>
      <div class="command-item-text">
        <div class="command-item-title">To-do list</div>
        <div class="command-item-description">Track tasks with a to-do list</div>
      </div>
    </div>
    <div class="command-item" data-type="code">
      <div class="command-item-icon">‚å®Ô∏è</div>
      <div class="command-item-text">
        <div class="command-item-title">Code</div>
        <div class="command-item-description">Add code with syntax highlighting</div>
      </div>
    </div>
    <div class="command-item" data-type="quote">
      <div class="command-item-icon">‚ùù</div>
      <div class="command-item-text">
        <div class="command-item-title">Quote</div>
        <div class="command-item-description">Capture a quote</div>
      </div>
    </div>
    <div class="command-item" data-type="bullet">
      <div class="command-item-icon">‚Ä¢</div>
      <div class="command-item-text">
        <div class="command-item-title">Bullet List</div>
        <div class="command-item-description">Create a simple bullet list</div>
      </div>
    </div>
    <div class="command-item" data-type="page">
      <div class="command-item-icon">üìÑ</div>
      <div class="command-item-text">
        <div class="command-item-title">New Page</div>
        <div class="command-item-description">Create a new linked page</div>
      </div>
    </div>
  </div>

  <div id="share-modal" class="modal">
    <div class="modal-content">
      <span class="close-button" onclick="closeShareModal()">&times;</span>
      <h2>Share Page: <span th:text="${title}"></span></h2>

      <div style="margin-bottom: 20px;">
        <h4>Publish to Web</h4>
        <label>
          <input type="checkbox" id="publish-checkbox" onchange="togglePublish()">
          <span id="publish-status-text">Make page public</span>
        </label>
        <div id="public-link-container" style="display: none; margin-top: 5px;">
          Public Link: <a id="public-link" href="#" target="_blank"></a>
        </div>
      </div>

      <div>
        <h4>Share with People</h4>
        <div style="display: flex; margin-bottom: 10px;">
          <input type="email" id="share-email-input" placeholder="Enter email address">
          <select id="share-access-select">
            <option value="view">Can view</option>
            <option value="edit">Can edit</option>
          </select>
          <button id="add-share-button" onclick="addShare()">Share</button>
        </div>
        <ul id="shared-users-list">
        </ul>
      </div>
    </div>
  </div>

  <script th:inline="javascript">
    // Ensure defaults are safe if backend data is missing unexpectedly
    window.PAGE_ID = /*[[${pageId}]]*/ null;
    window.PAGE_TITLE = /*[[${title}]]*/ "Untitled"; // Provide default title
    window.PAGE_CONTENT = /*[[${content}]]*/ "";
    window.IS_PUBLISHED = /*[[${isPublished}]]*/ false;
    window.SHARING_INFO = /*[[${sharingInfo}]]*/ {};
    window.CAN_EDIT = /*[[${canEdit}]]*/ false;
    window.PAGE_OWNER = /*[[${owner}]]*/ null;

    // Log received data for debugging frontend issues
    console.log("Page Data Received:", {
        pageId: window.PAGE_ID,
        title: window.PAGE_TITLE,
        isPublished: window.IS_PUBLISHED,
        canEdit: window.CAN_EDIT,
        owner: window.PAGE_OWNER,
        sharingInfo: window.SHARING_INFO
        // content omitted for brevity
    });
  /*]]>*/
</script>

  <script>
    async function fetchWithAuth(url, options = {}) {
        // Add authentication headers if necessary (e.g., Bearer token)
        const token = localStorage.getItem('firebaseIdToken'); // Assuming token is stored in localStorage
        const defaultHeaders = {
            'Content-Type': 'application/json',
        };
        if (token) {
            defaultHeaders['Authorization'] = `Bearer ${token}`;
        }

        const fetchOptions = {
            ...options,
            headers: {
                ...defaultHeaders,
                ...options.headers,
            },
        };

        const response = await fetch(url, fetchOptions);

        // Basic check for auth errors, adjust as needed for your auth flow
        if (response.status === 401 || response.status === 403) {
             console.error(`Authentication/Authorization error (${response.status}) for ${url}. Redirecting or showing error.`);
             alert(`Error: Access denied (${response.status}). Please ensure you are logged in and have permission.`);
             throw new Error(`Authentication required (status ${response.status})`);
        }

        return response;
    }
  </script>

  <script>
    // WebSocket connection and subscription
    let stompClient = null;

    function connectWebSocket() {
        const socket = new SockJS('/ws'); // Ensure this matches your WebSocket endpoint config
        stompClient = Stomp.over(socket);

        stompClient.connect({}, function (frame) {
            console.log('Connected to WebSocket: ' + frame);

            // Subscribe to child deletion events for the current page
            const subscriptionUrl = `/topic/pages/${window.PAGE_ID}/children/deleted`;
            console.log("Subscribing to:", subscriptionUrl);

            stompClient.subscribe(subscriptionUrl, function (message) {
                const deletedChildId = message.body;
                console.log(`[WebSocket] Received child deletion message for ID: ${deletedChildId}`);
                handleChildDeletion(deletedChildId);
            });

        }, function(error) {
            console.error('STOMP error: ' + error);
            // Optional: Implement reconnection logic here
            setTimeout(connectWebSocket, 5000); // Try to reconnect after 5 seconds
        });

        // Handle socket closure
        socket.onclose = function() {
            console.log('WebSocket connection closed. Attempting to reconnect...');
            stompClient = null; // Ensure client is reset
            setTimeout(connectWebSocket, 5000); // Try to reconnect after 5 seconds
        };
    }

    function handleChildDeletion(deletedChildId) {
        console.log(`[handleChildDeletion] Attempting to remove block for child ID: ${deletedChildId}`);
        if (!window.editor) {
            console.error("[handleChildDeletion] Editor not initialized, cannot remove block.");
            return;
        }
        const blockSelector = `.block[data-subpage-id='${deletedChildId}']`;
        const blockToRemove = document.querySelector(blockSelector);

        if (blockToRemove) {
            console.log(`[handleChildDeletion] Found block element, attempting deletion:`, blockToRemove);
            window.editor.deleteBlock(blockToRemove);

            // --- Verification Step ---
            // Use setTimeout to allow DOM update cycle
            setTimeout(() => {
                const blockStillExists = document.querySelector(blockSelector);
                if (blockStillExists) {
                    console.error(`[handleChildDeletion] Verification FAILED: Block ${deletedChildId} still exists in DOM after delete attempt.`);
                } else {
                    console.log(`[handleChildDeletion] Verification PASSED: Block ${deletedChildId} successfully removed from DOM.`);
                }
            }, 100); // Short delay for verification
            // --- End Verification ---

        } else {
            console.warn(`[handleChildDeletion] Block for deleted child ${deletedChildId} not found in the current view.`);
        }
    }

    class Slipstream {
      constructor(container) {
        this.container = container;
        this.converter = new showdown.Converter({
          tables: true,
          tasklists: true,
          strikethrough: true,
          literalMidWordUnderscores: true,
          simpleLineBreaks: true
        });
        this.commandMenu = document.getElementById('command-menu');
        this.activeBlock = null;
        this.isInEditMode = true;
        this.blockTypes = new Map();

        this.initializeEditor();
        this.setupEventListeners();
      }

      initializeEditor() {
        const pageTitle = window.PAGE_TITLE;
        const pageContent = window.PAGE_CONTENT;

        this.container.innerHTML = '';

        if (!window.PAGE_ID) {
            console.error("Page ID is missing. Cannot initialize editor correctly.");
            this.container.innerHTML = '<p style="color: red;">Error: Page data could not be loaded.</p>';
            document.getElementById('save-button')?.remove();
            document.getElementById('share-button')?.remove();
            return;
        }

        if (pageTitle && pageTitle !== "Untitled") {
            this.addTitleBlock(pageTitle);
        }

        if (pageContent) {
            this.loadContentFromMarkdown(pageContent);
        } else if (!pageTitle || pageTitle === "Untitled") {
            const initialBlock = this.addBlock();
            this.switchToEditMode(initialBlock);
        }

        if (window.CAN_EDIT) {
            const saveBtn = document.getElementById('save-button');
            if (saveBtn) {
                saveBtn.addEventListener('click', () => this.saveDocument());
            } else {
                 console.warn("Save button not found, cannot attach listener.");
            }
        } else {
            this.container.querySelectorAll('[contenteditable="true"]').forEach(el => {
                el.setAttribute('contenteditable', 'false');
            });
            this.container.querySelectorAll('.block-content:empty:before').forEach(el => {
                el.style.display = 'none';
            });
        }
      }

      addTitleBlock(title) {
        const titleBlock = document.createElement('div');
        titleBlock.className = 'block relative mb-6';
        titleBlock.innerHTML = `
          <div class="block-placeholder">üìÑ</div>
          <div class="block-content text-3xl font-bold" contenteditable="true">${title}</div>
          <div class="markdown-rendered prose text-3xl font-bold hidden"></div>
        `;

        this.container.appendChild(titleBlock);

        this.setupBlockEventListeners(titleBlock);
      }

      loadContentFromMarkdown(markdown) {
        const blocks = markdown.split(/\n\n+/);
        const subPageRegex = /\[üìÑ\s*(.*?)]\(\/view\/pages\/(page_[a-f0-9-]+)\)/;

        blocks.forEach(blockContent => {
          if (blockContent.trim()) {
            const match = blockContent.trim().match(subPageRegex);
            let block;
            if (match && match[0] === blockContent.trim()) {
              const title = match[1];
              const id = match[2];
              block = this.addBlock(null, id, title);
              const content = block.querySelector('.block-content');
              content.textContent = blockContent;
              this.updateBlockType(block);
              this.switchToRenderMode(block);
            } else {
              block = this.addBlock(null);
              const content = block.querySelector('.block-content');
              content.textContent = blockContent;
              this.updateBlockType(block);
              this.switchToRenderMode(block);
            }
          }
        });
      }

      setupEventListeners() {
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            this.hideCommandMenu();
          }
        });

        this.commandMenu.addEventListener('click', (e) => {
          const item = e.target.closest('.command-item');
          if (item) {
            this.applyCommand(item.dataset.type);
          }
        });

        document.addEventListener('click', (e) => {
          if (!this.commandMenu.contains(e.target) && !e.target.closest('.block-content')) {
            this.hideCommandMenu();
          }
        });

        this.container.addEventListener('click', (e) => {
            if (e.target === this.container) {
                const lastBlock = this.container.lastElementChild;
                if (lastBlock && lastBlock.classList.contains('block') && lastBlock.dataset.subpageId) {
                    console.log("Clicked empty space below a subpage block. Adding new block.");
                    const newBlock = this.addBlock(null);
                    this.switchToEditMode(newBlock);
                    console.log("Attempted focus via switchToEditMode for block added below subpage.");
                } else if (!lastBlock) {
                    console.log("Clicked empty editor. Adding initial block.");
                    const initialBlock = this.addBlock(null);
                    this.switchToEditMode(initialBlock);
                }
            }
        });
      }

      setupBlockEventListeners(block) {
        const content = block.querySelector('.block-content');
        const renderedContent = block.querySelector('.markdown-rendered');

        content.addEventListener('input', () => {
          this.handleContentChange(block);
        });

        content.addEventListener('keydown', (e) => {
          this.handleKeyDown(e, block);
        });

        content.addEventListener('focus', () => {
          this.setActiveBlock(block);
        });

        if (renderedContent) {
          renderedContent.addEventListener('click', (e) => {
            if (block.dataset.subpageId) {
                if (e.target.tagName === 'A' && e.target.href.includes('/view/pages/')) {
                } else {
                    e.preventDefault();
                }
            } else {
                this.switchToEditMode(block);
            }
          });
        }

        content.addEventListener('paste', (e) => {
          this.handlePaste(e, block);
        });

        content.addEventListener('blur', () => {
          if (block.dataset.subpageId) {
            const expectedTitle = block.dataset.subpageTitle || 'Untitled Page';
            const expectedId = block.dataset.subpageId;
            const expectedMarkdown = `[üìÑ ${expectedTitle}](/view/pages/${expectedId})`;
            if (content.textContent !== expectedMarkdown) {
              console.warn(`Subpage link block ${expectedId} content modified, restoring.`);
              content.textContent = expectedMarkdown;
            }
          }

          if (!this.commandMenu.contains(document.activeElement)) {
            this.switchToRenderMode(block);
          }
        });
      }

      setActiveBlock(block) {
        const allBlocks = this.container.querySelectorAll('.block');
        allBlocks.forEach(b => b.classList.remove('active'));
        block.classList.add('active');
        this.activeBlock = block;
      }

      handlePaste(e, block) {
        const target = e.target;
        if (!target.classList.contains('block-content')) return;
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
          if (items[i].type.indexOf("image") !== -1) {
            const blob = items[i].getAsFile();
            const reader = new FileReader();
            reader.onload = (event) => {
              const content = block.querySelector('.block-content');
              const imageMarkdown = `![Pasted Image](${event.target.result})`;
              content.textContent += imageMarkdown;
              this.handleContentChange(block);
            };
            reader.readAsDataURL(blob);
            e.preventDefault();
            break;
          }
        }
      }

      async saveDocument() {
        if (!window.CAN_EDIT) {
          alert("You do not have permission to save changes to this page.");
          return;
        }

        const pageId = window.PAGE_ID;

        if (!pageId) {
          alert('Could not determine page ID.');
          return;
        }

        const blocks = Array.from(this.container.querySelectorAll('.block'));
        let title = window.PAGE_TITLE;
        let contentBlocks = blocks;

        blocks.forEach(block => {
            if (block.dataset.subpageId) {
                const content = block.querySelector('.block-content');
                const expectedTitle = block.dataset.subpageTitle || 'Untitled Page';
                const expectedId = block.dataset.subpageId;
                const expectedMarkdown = `[üìÑ ${expectedTitle}](/view/pages/${expectedId})`;
                if (content.textContent !== expectedMarkdown) {
                    console.warn(`Correcting subpage link content for ${expectedId} before saving.`);
                    content.textContent = expectedMarkdown;
                }
            }
        });

        if (blocks.length > 0) {
            const firstBlockContent = blocks[0].querySelector('.block-content');
            if (firstBlockContent && (firstBlockContent.classList.contains('text-3xl') || blocks.length === 1)) {
                title = firstBlockContent.textContent.trim() || 'Untitled';
                contentBlocks = blocks.slice(1);
                console.log("Extracted Title:", title);
            } else {
                 console.log("First block doesn't seem like a title, using original title:", title);
            }
        } else {
             console.log("No blocks found, using original title:", title);
        }


        const documentMarkdown = contentBlocks.map(block => {
          const content = block.querySelector('.block-content');
          return content ? content.textContent : '';
        }).filter(text => text.trim() !== '').join('\n\n');

        console.log("Extracted Content Markdown:", documentMarkdown);


        try {
            const response = await fetchWithAuth(`/api/pages/${encodeURIComponent(pageId)}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    title: title,
                    content: documentMarkdown
                })
            });

            const data = await response.text();

            if (!response.ok) {
                throw new Error(data || `HTTP error! status: ${response.status}`);
            } else {
                console.log("Response from server:", data);
                document.title = title;
                window.PAGE_TITLE = title;
                alert('Page saved successfully!');
            }
        } catch (error) {
            if (!error.message.startsWith("Authentication required")) {
                console.error('Error:', error);
                alert(`An error occurred while saving the page: ${error.message}`);
            }
        }
      }

      switchToEditMode(block) {
        if (!block) {
            console.warn("[switchToEditMode] Called with null block.");
            return;
        }
        if (block.dataset.subpageId) {
            console.log("[switchToEditMode] Attempted to edit subpage link block. Action prevented.");
            return;
        }
        const content = block.querySelector('.block-content');
        const renderedContent = block.querySelector('.markdown-rendered');

        if (!content) {
            console.error("[switchToEditMode] Block content element not found for block:", block);
            return;
        }

        content.classList.remove('hidden');
        if (renderedContent) {
          renderedContent.classList.add('hidden');
        }
        this.setActiveBlock(block); // Set active before focusing

        setTimeout(() => {
            content.focus();
            this.placeCursorAtEnd(content); // Ensure cursor is placed
            console.log(`[switchToEditMode] Switched block ${block.id || '(no id)'} to edit mode and focused.`);
        }, 0);
      }

      switchToRenderMode(block) {
        const content = block.querySelector('.block-content');
        const renderedContent = block.querySelector('.markdown-rendered');
        if (content.textContent.trim() && renderedContent) {
          if (block.dataset.subpageId) {
              const title = block.dataset.subpageTitle || 'Untitled Page';
              const id = block.dataset.subpageId;
              renderedContent.innerHTML = `<a href="/view/pages/${id}" class="text-blue-600 hover:underline">üìÑ ${title}</a>`;
          } else {
              renderedContent.innerHTML = this.converter.makeHtml(content.textContent);
          }

          if (content.classList.contains('code-block')) {
            renderedContent.classList.add('code-block');
          }
          content.classList.add('hidden');
          renderedContent.classList.remove('hidden');
        } else if (renderedContent) {
            renderedContent.innerHTML = '';
            renderedContent.classList.add('hidden');
            content.classList.remove('hidden');
        }
      }

      placeCursorAtEnd(element) {
        const range = document.createRange();
        const selection = window.getSelection();
        if (element.childNodes.length > 0) {
          const lastNode = element.childNodes[element.childNodes.length - 1];
          range.setStart(lastNode, lastNode.length || 0);
        } else {
          range.setStart(element, 0);
        }
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      }

      handleContentChange(block) {
        const content = block.querySelector('.block-content');
        const text = content.textContent;
        if (text === '/') {
          this.showCommandMenu(block);
        } else if (!text.startsWith('/')) {
          this.hideCommandMenu();
          this.updateBlockType(block);
        }
      }

      updateBlockType(block) {
        const content = block.querySelector('.block-content');
        const placeholder = block.querySelector('.block-placeholder');
        const text = content.textContent;
        content.className = 'block-content';
        placeholder.textContent = '‚ú¶';
        if (text.startsWith('# ')) {
          content.classList.add('heading-1');
          placeholder.textContent = 'H1';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'h1');
        } else if (text.startsWith('## ')) {
          content.classList.add('heading-2');
          placeholder.textContent = 'H2';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'h2');
        } else if (text.startsWith('- [ ] ') || text.startsWith('- [x] ')) {
          placeholder.textContent = '‚òê';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'todo');
        } else if (text.startsWith('```') && text.endsWith('```')) {
          content.classList.add('code-block');
          placeholder.textContent = '‚å®Ô∏è';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'code');
        } else if (text.startsWith('> ')) {
          content.classList.add('quote-block');
          placeholder.textContent = '‚ùù';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'quote');
        } else if (text.startsWith('- ')) {
          placeholder.textContent = '‚Ä¢';
          this.blockTypes.set(block.id || this.assignBlockId(block), 'bullet');
        } else {
          this.blockTypes.delete(block.id || '');
        }
      }

      assignBlockId(block) {
        const id = 'block-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
        block.id = id;
        return id;
      }

      handleKeyDown(e, block) {
        if (!block) {
            console.warn("handleKeyDown called without a block.");
            return;
        }

        if (e.key === '/') {
          const content = block.querySelector('.block-content');
          if (content.textContent === '') {
            this.showCommandMenu(block);
            return;
          }
        }
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          let newBlock;

          if (block.dataset.subpageId) {
              console.log("Enter pressed on subpage block. Adding new block after.");
              newBlock = this.addBlock(block);
              this.switchToEditMode(newBlock);
              console.log("Attempted focus via switchToEditMode for block added after subpage.");
              return;
          }
          const content = block.querySelector('.block-content');
          const text = content.textContent;
          const blockType = this.blockTypes.get(block.id || '');
          if (blockType === 'h1' || blockType === 'h2') {
            newBlock = this.addBlock(block);
            this.switchToEditMode(newBlock);
            return;
          }
          if (text.match(/^- \[(x| )\] /)) {
            newBlock = this.addBlock(block);
            const newContent = newBlock.querySelector('.block-content');
            newContent.textContent = '- [ ] ';
            this.updateBlockType(newBlock);
            this.switchToEditMode(newBlock);
            return;
          }
          if (text.startsWith('- ')) {
            newBlock = this.addBlock(block);
            const newContent = newBlock.querySelector('.block-content');
            newContent.textContent = '- ';
            this.updateBlockType(newBlock);
            this.switchToEditMode(newBlock);
            return;
          }
          if (content.classList.contains('code-block') && !text.endsWith('```')) {
            document.execCommand('insertText', false, '\n');
            return;
          }
          newBlock = this.addBlock(block);
          if (blockType && blockType !== 'h1' && blockType !== 'h2') {
            const newContent = newBlock.querySelector('.block-content');
            switch(blockType) {
              case 'todo':
                newContent.textContent = '- [ ] ';
                break;
              case 'bullet':
                newContent.textContent = '- ';
                break;
              case 'quote':
                newContent.textContent = '> ';
                break;
            }
            this.updateBlockType(newBlock);
          }
          this.switchToEditMode(newBlock);
          return;
        }
        if (e.key === 'Backspace') {
          const content = block.querySelector('.block-content');
          if (content.textContent === '' && this.container.children.length > 1) {
            e.preventDefault();
            this.deleteBlock(block);
            return;
          }
        }
        if (e.key === 'Tab' && block.querySelector('.block-content').classList.contains('code-block')) {
          e.preventDefault();
          document.execCommand('insertText', false, '    ');
          return;
        }
      }

      showCommandMenu(block) {
        if (block.dataset.subpageId) {
            return;
        }
        const rect = block.getBoundingClientRect();
        this.commandMenu.style.display = 'block';
        this.commandMenu.style.top = `${rect.bottom + window.scrollY}px`;
        this.commandMenu.style.left = `${rect.left + window.scrollX}px`;
        this.activeBlock = block;
      }

      hideCommandMenu() {
        this.commandMenu.style.display = 'none';
      }

      applyCommand(type) {
        if (!this.activeBlock) return;
        const content = this.activeBlock.querySelector('.block-content');
        let prefix = '';
        if (type === 'page') {
          this.hideCommandMenu();
          window.currentBlock = this.activeBlock;
          createNewPage();
          return;
        }
        switch(type) {
          case 'h1':
            prefix = '# ';
            content.className = 'block-content heading-1';
            break;
          case 'h2':
            prefix = '## ';
            content.className = 'block-content heading-2';
            break;
          case 'todo':
            prefix = '- [ ] ';
            break;
          case 'code':
            prefix = '```\n\n```';
            content.className = 'block-content code-block';
            break;
          case 'quote':
            prefix = '> ';
            content.className = 'block-content quote-block';
            break;
          case 'bullet':
            prefix = '- ';
            break;
        }
        content.textContent = '';
        content.textContent = prefix;
        this.updateBlockType(this.activeBlock);
        this.blockTypes.set(this.activeBlock.id || this.assignBlockId(this.activeBlock), type);
        content.focus();
        if (type === 'code') {
          this.placeCursorAtPosition(content, 4);
        } else {
          this.placeCursorAtPosition(content, prefix.length);
        }
        this.hideCommandMenu();
      }

      placeCursorAtPosition(element, position) {
        const range = document.createRange();
        const selection = window.getSelection();
        if (element.firstChild) {
          const textNode = element.firstChild;
          const pos = Math.min(position, textNode.length);
          range.setStart(textNode, pos);
        } else {
          const textNode = document.createTextNode(element.textContent);
          element.appendChild(textNode);
          const pos = Math.min(position, textNode.length);
          range.setStart(textNode, pos);
        }
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      }

      addBlock(afterBlock = null, subPageId = null, subPageTitle = null) {
        const block = document.createElement('div');
        const id = 'block-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
        block.id = id;
        block.className = 'block relative';
        block.innerHTML = `
          <div class="block-placeholder"> ‚ú¶ </div>
          <div class="block-content" contenteditable="true"></div>
          <div class="markdown-rendered prose hidden"></div>
        `;

        const content = block.querySelector('.block-content');

        if (subPageId) {
            block.dataset.subpageId = subPageId;
            block.dataset.subpageTitle = subPageTitle || 'Untitled Page';
            block.querySelector('.block-placeholder').innerHTML = `<a href="/view/pages/${subPageId}" title="Go to page: ${subPageTitle || 'Untitled Page'}">üìÑ</a>`;
            content.setAttribute('contenteditable', 'false');
        }

        if (afterBlock) {
          if (afterBlock.nextSibling) {
            this.container.insertBefore(block, afterBlock.nextSibling);
          } else {
            this.container.appendChild(block);
          }
        } else {
          this.container.appendChild(block);
        }

        this.setupBlockEventListeners(block);

        return block;
      }

      deleteBlock(block) {
        console.log(`[deleteBlock] Function called for block:`, block);
        if (!block) {
            console.warn("[deleteBlock] Attempted to delete a null block.");
            return;
        }

        const blockId = block.id || '(no id)';
        console.log(`[deleteBlock] Attempting to remove block ${blockId}`);

        const previousBlock = block.previousElementSibling;
        const nextBlock = block.nextElementSibling;
        this.blockTypes.delete(block.id || '');

        if (this.container.contains(block)) {
            console.log(`[deleteBlock] About to remove block ${blockId} from DOM.`);
            try {
                this.container.removeChild(block);
                console.log(`[deleteBlock] Successfully removed block ${blockId} from DOM.`);
            } catch (error) {
                console.error(`[deleteBlock] Error removing block ${blockId} from DOM:`, error);
            }
        } else {
             console.warn(`[deleteBlock] Attempted to remove block ${blockId} which is not in the container.`);
        }

        let focused = false;
        if (previousBlock && !previousBlock.dataset.subpageId) {
          console.log(`[deleteBlock] Focusing previous editable block: ${previousBlock.id}`);
          this.switchToEditMode(previousBlock);
          focused = true;
        } else if (nextBlock && !nextBlock.dataset.subpageId) {
          console.log(`[deleteBlock] Previous block unsuitable, focusing next editable block: ${nextBlock.id}`);
          this.switchToEditMode(nextBlock);
          focused = true;
        } else if (this.container.children.length === 0) {
            console.log("[deleteBlock] No blocks left, adding a new empty one.");
            const newBlock = this.addBlock();
            this.switchToEditMode(newBlock);
            focused = true;
        } else {
             const lastEditableBlock = Array.from(this.container.querySelectorAll('.block:not([data-subpage-id])')).pop();
             if (lastEditableBlock) {
                 console.log("[deleteBlock] Previous/Next unsuitable, focusing last editable block:", lastEditableBlock.id);
                 this.switchToEditMode(lastEditableBlock);
                 focused = true;
             }
        }

        if (!focused) {
             console.log("[deleteBlock] No suitable block found to focus after deletion.");
        }
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      if (!window.PAGE_ID) {
           console.error("Critical Error: Page ID not provided by backend. Aborting page initialization.");
           document.getElementById('editor-container').innerHTML = '<h1 style="color: red; text-align: center; margin-top: 50px;">Error loading page data.</h1>';
           return;
      }

      const editorContainer = document.getElementById('editor');
      if (editorContainer) {
          window.editor = new Slipstream(editorContainer);
      } else {
          console.error("Editor container not found!");
      }

      if (window.PAGE_ID) {
          connectWebSocket();
      }
    });

    async function createNewPage() {
      const modal = document.createElement('div');
      modal.className = 'fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50';
      modal.innerHTML = `
        <div class="bg-white p-6 rounded-lg shadow-lg max-w-md w-full">
          <h2 class="text-xl font-bold mb-4">Create New Page</h2>
          <form id="create-page-form">
            <div class="mb-4">
              <label class="block text-sm font-medium mb-1" for="page-title">Page Title:</label>
              <input class="w-full p-2 border rounded" type="text" id="page-title" name="title" required>
            </div>
            <div class="flex justify-end gap-2">
              <button type="button" id="cancel-page" class="px-4 py-2 bg-gray-200 rounded">Cancel</button>
              <button type="submit" class="px-4 py-2 bg-blue-500 text-white rounded">Create</button>
            </div>
          </form>
        </div>
      `;
      document.body.appendChild(modal);
      
      setTimeout(() => {
        document.getElementById('page-title').focus();
      }, 100);
      
      document.getElementById('create-page-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const title = document.getElementById('page-title').value.trim();
        const parentPageId = window.PAGE_ID;
        console.log("Creating new page with parent ID:", parentPageId);
        if (!title) return;

        try {
            const response = await fetchWithAuth('/api/pages', {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json' 
                },
                body: JSON.stringify({
                    title: title,
                    content: "", 
                    parentPageId: parentPageId,
                    type: 'content'
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
            }

            const newPageId = await response.text();
            document.body.removeChild(modal);

            if (window.currentBlock && window.editor) {
                window.currentBlock.dataset.subpageId = newPageId;
                window.currentBlock.dataset.subpageTitle = title;

                const placeholder = window.currentBlock.querySelector('.block-placeholder');
                const content = window.currentBlock.querySelector('.block-content');

                placeholder.innerHTML = `<a href="/view/pages/${newPageId}" title="Go to page: ${title}">üìÑ</a>`;

                content.textContent = `[üìÑ ${title}](/view/pages/${newPageId})`;
                content.setAttribute('contenteditable', 'false');

                window.editor.updateBlockType(window.currentBlock);
                window.editor.switchToRenderMode(window.currentBlock);

                await window.editor.saveDocument();

                window.currentBlock = null;
            }

            if (confirm(`Page '${title}' created! Do you want to open it now?`)) {
                window.location.href = `/view/pages/${newPageId}`;
            }
        } catch (error) {
            console.error('Error:', error);
            alert(`An error occurred while creating the page: ${error.message}`);
            const modal = document.getElementById('create-page-form')?.closest('.fixed');
            if (modal && document.body.contains(modal)) {
                document.body.removeChild(modal);
            }
            window.currentBlock = null;
        }
      });

      document.getElementById('cancel-page').addEventListener('click', () => {
        const modal = document.getElementById('create-page-form')?.closest('.fixed');
        if (modal && document.body.contains(modal)) {
            document.body.removeChild(modal);
        }
        window.currentBlock = null;
      });
    }
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.1/sockjs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
</body>
</html>
